//
//  CwlMachBadInstructionHandler.h
//  CwlPreconditionTesting
//
//  Created by Matt Gallagher on 2016/01/10.
//  Copyright Â© 2016 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

#import <Foundation/Foundation.h>
#import <mach/exception_types.h>
#import <mach/ndr.h>
#import <mach/mach_port.h>
#import <mach/exception.h>
#import <mach/mach.h>
#import <pthread.h>

#if TARGET_OS_OSX || TARGET_OS_IOS

extern bool _swift_disableExclusivityChecking;
extern bool _swift_reportFatalErrorsToDebugger;

NS_ASSUME_NONNULL_BEGIN

extern boolean_t mach_exc_server(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

// The request_mach_exception_raise_t struct is passed to mach_msg which assumes its exact layout. To avoid problems with different layouts, we keep the definition in C rather than Swift.
typedef struct
{
	mach_msg_header_t Head;
	/* start of the kernel processed data */
	mach_msg_body_t msgh_body;
	mach_msg_port_descriptor_t thread;
	mach_msg_port_descriptor_t task;
	/* end of the kernel processed data */
	NDR_record_t NDR;
	exception_type_t exception;
	mach_msg_type_number_t codeCnt;
	int64_t code[2];
	int flavor;
	mach_msg_type_number_t old_stateCnt;
	natural_t old_state[224];
} request_mach_exception_raise_t;

// The reply_mach_exception_raise_state_t struct is passed to mach_msg which assumes its exact layout. To avoid problems with different layouts, we keep the definition in C rather than Swift.
typedef struct
{
	mach_msg_header_t Head;
	NDR_record_t NDR;
	kern_return_t RetCode;
	int flavor;
	mach_msg_type_number_t new_stateCnt;
	natural_t new_state[224];
} reply_mach_exception_raise_state_t;

typedef struct
{
	mach_port_t exception_port;
	exception_type_t exception;
	mach_exception_data_type_t const * _Nullable code;
	mach_msg_type_number_t codeCnt;
	int32_t * _Nullable flavor;
	natural_t const * _Nullable old_state;
	mach_msg_type_number_t old_stateCnt;
	thread_state_t _Nullable new_state;
	mach_msg_type_number_t * _Nullable new_stateCnt;
} bad_instruction_exception_reply_t;

NSArray<NSValue *> *LTGetSegments(void);

BOOL isExceptionComingFromSwift(__uint64_t address);

__attribute__((used)) static void exception_server(mach_port_t exceptionPort) {
    mach_msg_return_t rt;
    mach_msg_header_t *msg;
    mach_msg_header_t *reply;

    msg = malloc(sizeof(mach_msg_header_t));
    reply = malloc(sizeof(mach_msg_header_t));

    while (1) {
         rt = mach_msg(msg, MACH_RCV_MSG, 0, sizeof(mach_msg_header_t), exceptionPort, 0, MACH_PORT_NULL);
         assert(rt == MACH_MSG_SUCCESS);

         // Call out to the mach_exc_server generated by mig and mach_exc.defs.
         // This will in turn invoke one of:
         // mach_catch_exception_raise()
         // mach_catch_exception_raise_state()
         // mach_catch_exception_raise_state_identity()
         // .. depending on the behavior specified when registering the Mach exception port.
         mach_exc_server(msg, reply);
        
         // Send the now-initialized reply
         rt = mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
         assert(rt == MACH_MSG_SUCCESS);
    }
}

//struct MachContext {
//  masks,
//  count,
//  ports,
//  behaviors,
//  flavors,
//  currentExceptionPort,
//  pthread_t handlerThread: pthread_t?
//}

//BadInstructionException catchBadInstruction2(void (^block)(void)) {
	// Suppress Swift runtime's direct triggering of the debugger and exclusivity checking which crashes when we throw past it
//	let previousExclusivity = _swift_disableExclusivityChecking
//	let previousReporting = _swift_reportFatalErrorsToDebugger
//	_swift_disableExclusivityChecking = true
//	_swift_reportFatalErrorsToDebugger = false
//	defer {
//		_swift_reportFatalErrorsToDebugger = previousReporting
//		_swift_disableExclusivityChecking = previousExclusivity
//	}
//  mach_port_t port;
//  mach_port_t receive;
//  int err;
//
//  /* Allocate a port.  */
//    // 1.
//  err = mach_port_allocate (mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
//  
//// 2.
//    mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
//
//    exception_mask_array_t masks;
//    mach_msg_type_number_t *masksCnt;
//    exception_handler_array_t old_handlers;
//    exception_behavior_array_t old_behaviors;
//    exception_flavor_array_t old_flavors;
//
//    // 3.
//    thread_swap_exception_ports(mach_thread_self(), EXC_MASK_BREAKPOINT, port,
//                                EXCEPTION_STATE | MACH_EXCEPTION_CODES, ARM_THREAD_STATE64,
//                                masks, masksCnt, old_handlers, old_behaviors, old_flavors);
//
////		let currentExceptionPtr = context.currentExceptionPort
////		try kernCheck { context.withUnsafeMutablePointers { masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr in
////			// 3. Apply the mach port as the handler for this thread
////            #if (os(macOS) || os(iOS)) && arch(x86_64)
////                return thread_swap_exception_ports(mach_thread_self(), EXC_MASK_BAD_INSTRUCTION, currentExceptionPtr, Int32(bitPattern: UInt32(EXCEPTION_STATE) | MACH_EXCEPTION_CODES), x86_THREAD_STATE64, masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr)
////            #elseif os(iOS)
////                return thread_swap_exception_ports(mach_thread_self(), EXC_MASK_BREAKPOINT, currentExceptionPtr, Int32(bitPattern: UInt32(EXCEPTION_STATE) | MACH_EXCEPTION_CODES), ARM_THREAD_STATE64, masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr)
////            #endif
////		} }
//
//    
//    
//    // 4.
//    pthread_create(&handlerThread, nil, exception_server, c);
//
//    BadInstructionException.catchException(in: block);
//     
//    // 6.
//    thread_swap_exception_ports(mach_thread_self(), EXC_MASK_BREAKPOINT, 0, EXCEPTION_DEFAULT, THREAD_STATE_NONE, masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr);
//
//    // 7.
//    mach_port_destroy(mach_task_self(), port);
//
////		defer { context.withUnsafeMutablePointers { masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr in
////			// 6. Unapply the mach port
////			_ = thread_swap_exception_ports(mach_thread_self(), EXC_MASK_BREAKPOINT, 0, EXCEPTION_DEFAULT, THREAD_STATE_NONE, masksPtr, countPtr, portsPtr, behaviorsPtr, flavorsPtr)
////		} }
//
////		try withUnsafeMutablePointer(to: &context) { c throws in
////			// 4. Create the thread
////			let e = pthread_create(&handlerThread, nil, exception_server, c)
////			guard e == 0 else { throw PthreadError.code(e) }
////
////            BadInstructionException.machContext = c
////
////			// 5. Run the block
////			result = BadInstructionException.catchException(in: block)
////		}
////	} catch {
////		// Should never be reached but this is testing code, don't try to recover, just abort
////		fatalError("Mach port error: \(error)")
////	}
////
////	return result
//}

NS_ASSUME_NONNULL_END

#endif
